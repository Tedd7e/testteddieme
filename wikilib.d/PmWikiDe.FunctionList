version=pmwiki-2.3.17 ordered=1 urlencoded=1
author=MFWolff
charset=UTF-8
csum=see $PageIndexTermsFunction (+33)
ctime=1467822881
name=PmWikiDe.FunctionList
rev=7
targets=Cookbook.Functions,Cookbook.ParseArgs,PmWikiDe.Functions,PmWiki.Functions,PmWikiDe.CondAuth,PmWikiDe.BasicVariables,PmWikiDe.CondExpr,PmWikiDe.PathVariables,PmWiki.MakeLink,PmWikiDe.PagelistVariables,Category.PmWikiInternals,!PmWikiInternals,Category.PmWikiDeveloper,!PmWikiDeveloper
text=(:title Funktionenliste:)%0a(:Summary: Eine einfache Liste der von PmWiki zur Verfügung gestellten Funktionen. :)%0a(:Original_Page: PmWiki.{$Name}:)%0a(:Translation_Date: 2016-06-07:)%0a(:Translation_Status: %25green%25fertig%25%25:)%0a(:Audience: Entwickler:)%0a%0a{$:Summary}.  Eventuell mit ein bisschen Fleisch versehen mit weiteren Beschreibungen und Verweisen auf passende Seiten.%0a  %0a!! pmwiki.php:%0a%0a!!! Helper-Funktionen%0a||style="left-margin:0; padding-left:1em"%0a||[[Cookbook/Functions#SDV|SDV(&$v,$x)]] ||"set default value" -- weist $x der Variablen $v zu, aber nur, wenn $v nicht bereits definiert ist (z. B. in ''config.php'') ||%0a||SDVA(&$var,$val)           ||"set default value array" -- weist Array $val das Array $var zu für undefinierte Elemente  ||%0a||PUE($x)                    ||url encode $x ||%0a||IsEnabled(&$var,$f=0)      ||liefert $var, wenn $var gesetzt ist, sonst liefert es $f ||%0a||mkdirp($dir)               ||erzeugt Verzeichnis $dir, wenn es nicht exsistiert (mit angemessenen Rechten) ||%0a||fixperms($fname, $add = 0) ||korrigiert Dateirechte für $fname ||%0a||stripmagic($x)             ||macht die Effekte von PHP's (defekten) magic_quotes-Setzungen rückgängig||%0a||Lock($op)                  ||stellt ein Semaphore für Wikiprozesse zur Verfügung (vermeidet Schreib/Lese--Konflikte) ||%0a||[[Cookbook:ParseArgs|ParseArgs($x)]] ||durchläuft Strings, die Argumentlisten enthalten ||%0a||StopWatch($x)              ||mark elapsed time in processing ||%0a||[[Functions#pmcrypt|pmcrypt($pass, $salt)]] ||erzeugt oder prüft ein Passwort-Hash ||%0a%0a!!! Markup helper functions%0a  PSS($x)  - entfernt backslashes (hinzugefügt durch die /e-Option bei preg_replace) von $x. [[PmWiki/functions(#PSS)]]%0a  PVS($x)  - Wandelt \n\n-Sequenzen in %3c:vspace> um%0a  PVSE($x) - Wandelt spezielle Zeichen in HTML-Entities um (außer Anführungszeichen) und wandelt \n\nSequenzen in %3c:vspace> um%0a  PZZ($x,$y='') - liefert einen null-String (wird wegen ihres Seiteneffekts auf die Auswertung von $x und $y eingesetzt)%0a  PRR($x=NULL)  - zeigt an, dass wir den Markup-Prozess erneut starten müssen%0a  PQA($x) - "prepare quoted arguments" -- quote any attributes in HTML tags%0a  NoCache($x='') - zeigt an, dass die aktuelle Seite nicht 'gecacht' werden soll%0a%0a!!! Markup functions%0a  CompareArgs($arg)%0a  [[CondAuth]]($pagename, $condparm)%0a  [[CondExpr]]($pagename, $condname, $condparm)%0a  SetTmplDisplay($var, $val)%0a  AsSpaced($text) %0a  MatchNames($pagelist, $pat, $caseinsensitive = true) %0a-> $list ist ein Zeichenkettenarray (tokens etc.), das geprüft werden soll. $pat ist ein Muster (z.&nbsp;B. "example,exemplar") oder ein Array aus Mustern (die Jokerzeichen * und ? enthalten können). Wenn $pat ein Array aus Mustern ist, muss ein $list-Element auf jedes Muster des Arrays passen. MatchNames gibt ein Array aus den $list-Elementen zurück, die auf die Muster passen.%0a  MatchPageNames($pagelist, $pat, $caseinsensitive = true) %0a  FixGlob($x, $rep = '$1*.$2') %0a  ResolvePageName($pagename)%0a  MakePageName($basepage,$x)%0a  PCache($pagename, $page)%0a  SetProperty($pagename, $prop, $value, $sep = NULL)%0a  PageVar($pagename, $var, $pn = '')%0a  FmtPageName($fmt, $pagename)%0a  XL($key)%0a  XLSDV($lang,$a)%0a  XLPage($lang,$p)%0a  CmpPageAttr($a, $b)%0a  PageStore($d='$WorkDir/$FullName', $w=0)%0a  pagefile($pagename)%0a  read($pagename, $since=0)%0a  write($pagename,$page)%0a  exists($pagename)%0a  delete($pagename)%0a  ls($pats=NULL)%0a  ReadPage($pagename, $since=0) - liefert ein Array, jedes Element enthält eine einzelne Zeile, zerlegt durch '=' als array($key => $value)%0a  WritePage($pagename,$page)%0a  PageExists($pagename)%0a  ListPages($pat=NULL)%0a  RetrieveAuthPage($pagename, $level, $authprompt=true, $since=0) - liest eine Seite mit Beachtung der Autentifikationsmechanismen (hookable) ([[PmWikiDe/Functions#RetrieveAuthPage|reference]])%0a  Abort($msg)%0a  Redirect($pagename,$urlfmt='$PageUrl')%0a  PrintFmt($pagename,$fmt)%0a  PrintWikiPage($pagename, $wikilist=NULL, $auth='read')%0a  Keep($x, $pool=NULL) - der $x-String wird unverändert an die Ausgabe weitergegeben%0a  CondText($pagename,$condspec,$condtext)%0a  IncludeText($pagename, $inclspec)%0a  RedirectMarkup($pagename, $opt)%0a  Block($b)%0a  FormatTableRow($x)%0a  WikiLink($pagename, $word)%0a  LinkIMap($pagename,$imap,$path,$title,$txt,$fmt=NULL)%0a  LinkPage($pagename,$imap,$path,$title,$txt,$fmt=NULL)%0a  MakeLink($pagename,$tgt,$txt=NULL,$suffix=NULL,$fmt=NULL) - erzeugt einen Verweis mit den passenden Site-Infos, siehe [[PmWiki/MakeLink]]%0a  [[Functions#Markup|Markup]]($id,$cmd,$pat=NULL,$rep=NULL)%0a  DisableMarkup()%0a  mpcmp($a,$b) { return @strcmp($a['seq'].'=',$b['seq'].'='); }%0a  BuildMarkupRules()%0a  MarkupToHTML($pagename, $text, $opt = NULL)%0a  HandleBrowse($pagename, $auth = 'read')%0a  EditTemplate($pagename, &$page, &$new)%0a  RestorePage($pagename,&$page,&$new,$restore=NULL)%0a  ReplaceOnSave($pagename,&$page,&$new)%0a  SaveAttributes($pagename,&$page,&$new)%0a  PostPage($pagename, &$page, &$new)%0a  PostRecentChanges($pagename,&$page,&$new)%0a  PreviewPage($pagename,&$page,&$new)%0a  HandleEdit($pagename, $auth = 'edit')%0a  HandleSource($pagename, $auth = 'read')%0a  PmWikiAuth($pagename, $level, $authprompt=true, $since=0) - liest eine Seite mit Beachtung der Autentifikationsmechanismen%0a  IsAuthorized($chal, $source, &$from)%0a  SessionAuth($pagename, $auth = NULL)%0a  PrintAttrForm($pagename)%0a  HandleAttr($pagename, $auth = 'attr')%0a  HandlePostAttr($pagename, $auth = 'attr')%0a  HandleLogoutA($pagename, $auth = 'read')%0a  HandleLoginA($pagename, $auth = 'login')%0a%0a!! scripts/author.php:%0a  RequireAuthor($pagename, &$page, &$new)%0a%0a!! scripts/authuser.php:%0a  AuthUserId($pagename, $id, $pw=NULL)%0a  AuthUserConfig($pagename, $id, $pw, $pwlist)%0a  AuthUserHtPasswd($pagename, $id, $pw, $pwlist)%0a  AuthUserLDAP($pagename, $id, $pw, $pwlist)%0a  _crypt($plain, $salt=null)%0a%0a!! scripts/compat1x.php:%0a  ConvertV1WikiD($path) is a  that allows pages to be converted (?)%0a  read($pagename)%0a  UseV1WikiD($path)%0a  ConvertV1WikiD($path)%0a%0a!! scripts/crypt.php:%0a  HandleCrypt($pagename, $auth='read')%0a%0a!! scripts/diag.php:%0a  Ruleset()%0a  HandleRuleset($pagename)%0a  StopWatchHTML()%0a%0a!! scripts/draft.php:%0a  EditDraft(&$pagename, &$page, &$new)%0a%0a!! scripts/feeds.php:%0a  HandleFeed($pagename, $auth = 'read')%0a  RSSEnclosure($pagename, &$page, $k)%0a%0a!! scripts/forms.php:%0a  InputMarkup($pagename, $type, $args)%0a%0a!! scripts/guiedit.php:%0a  GUIButtonCode($pagename)%0a%0a!! scripts/httpauth.php:%0a  HTTPBasicAuthPrompt($pagename)%0a%0a!! scripts/notify.php:%0a  NotifyCheck($pagename)%0a  PostNotify($pagename, &$page, &$new)%0a  NotifyUpdate($pagename, $dir='')%0a%0a!! scripts/pagelist.php:%0a  SearchBox($pagename, $opt)%0a  FmtPageList($outfmt, $pagename, $opt)%0a  MakePageList($pagename, $opt, $retpages = 1)%0a  SortPageList(&$matches, $order)%0a  HandleSearchA($pagename, $level = 'read')%0a  FPLTemplate($pagename, &$matches, $opt)%0a  PageIndexTerms($terms) - siehe $PageIndexTermsFunction%0a  PageIndexUpdate($pagelist, $dir = '')%0a  PageIndexGrep($terms, $invert = false)%0a  PostPageIndex($pagename, &$page, &$new)%0a%0a!! scripts/pagerev.php:%0a  LinkSuppress($pagename,$imap,$path,$title,$txt,$fmt=NULL)%0a  PrintDiff($pagename)%0a  HandleDiff($pagename, $auth='read')%0a%0a!! scripts/phpdiff.php:%0a  PHPDiff($old,$new)%0a%0a!! scripts/simuledit.php:%0a  Merge($newtext,$oldtext,$pagetext)%0a  MergeSimulEdits($pagename,&$page,&$new)%0a%0a!! scripts/skins.php:%0a  SetSkin($pagename, $skin)%0a  LoadPageTemplate($pagename,$tfilefmt)%0a  PrintSkin($pagename, $arg)%0a    verbunden mit %0a      $PageEndFmt = "function:PrintSkin End"%0a      $PageStartFmt = "function:PrintSkin Start"%0a%0a!! scripts/stdmarkup.php:%0a  PreserveText($sigil, $text, $lead)%0a  PrintMetaTags($pagename, $args)%0a  TrackAnchors($x) { global $SeenAnchor; return @$SeenAnchor[$x]++; }%0a  WSIndent($i)%0a  Cells($name,$attr)%0a  MarkupMarkup($pagename, $text, $opt = '')%0a  CondDate($condparm)%0a%0a!! scripts/trails.php:%0a  ReadTrail($pagename,$trailname)%0a  MakeTrailStop($pagename,$trailname)%0a  MakeTrailStopB($pagename,$trailname)%0a  MakeTrailPath($pagename,$trailname)%0a%0a!! scripts/transition.php:%0a  FPLByGroup($pagename, &$matches, $opt)%0a  GUIEdit($pagename, &$page, &$new)%0a%0a!! scripts/upload.php:%0a  MakeUploadName($pagename,$x)%0a  LinkUpload($pagename, $imap, $path, $title, $txt, $fmt=NULL)%0a  HandleUpload($pagename, $auth = 'upload')%0a  HandleDownload($pagename, $auth = 'read')%0a  HandlePostUpload($pagename, $auth = 'upload')%0a  UploadVerifyBasic($pagename,$uploadfile,$filepath)%0a  dirsize($dir)%0a  FmtUploadList($pagename, $args)%0a  AttachExist($pagename)%0a%0a!! scripts/urlapprove.php:%0a  LinkHTTP($pagename,$imap,$path,$title,$txt,$fmt=NULL)%0a  ReadApprovedUrls($pagename)%0a  HandleApprove($pagename, $auth='edit')%0a  BlockUnapprovedPosts($pagename, &$page, &$new)%0a%0a!! scripts/vardoc.php:%0a  VarLink($pagename,$tgt,$txt)%0a  VarIndexLoad($pagename)%0a  VarIndexList($pagename)%0a%0a!! scripts/wikistyles.php:%0a  ApplyStyles($x)%0a%0a!! scripts/xlpage-utf-8.php:%0a  utf8toupper($x)%0a%0aCategory: [[!PmWiki Internals]] [[!PmWiki Developer]]
time=1672987701
title=Funktionenliste
