version=pmwiki-2.3.9 ordered=1 urlencoded=1
author=MFWolff
charset=UTF-8
csum=hlt php (+415)
ctime=1310551093
name=PmWikiDe.CustomPagelistSortOrder
rev=6
targets=PmWikiDe.BasicVariables,PmWikiDe.PagelistVariables,Cookbook.CustomPagelistSortOrderFunctions
text=(:title Angepasste Seitenlistenreihenfolge:)%0a(:Summary: So setzen Sie eine angepasste Reihenfolge für [[PmWikiDe/page lists|+]]:)%0a(:Original_Page: PmWiki.{$Name}:)%0a(:Translation_Date: 2011-07-13:)%0a(:Translation_Status: %25green%25fertig%25%25:)%0a(:Audience: Administratoren:)%0a%0aPmWiki kann für Seitenlisten angepasste @@''order=''@@-Werte enthalten, die der Administrator in der ''/local/config.php'' vordefiniert. Zuerst müssen wir PmWiki mitteilen, welche Funktion aufgerufen werden soll für unseren selbstdefinierten @@''order=''@@-Parameter.%0a%0aAls Beispiel nehmen wir eine @@Daten@@-Seite, die Seitentext-Variablen enthält, in denen Daten über Bücher gespeichert werden. Die Seite @@Daten-Gruppe.SeitenName@@ enthält die kommaseparierten Werte @@$:Year@@ (Jahr der Veröffentlichung, @@$:Work@@ (Titel des Buches) und @@$:Author@@ (Autor des Buches). In manchen Fällen sollen die Daten für die Sortierreihenfolge für @@Gruppe.SeitenName@@ von diesen korrespondierenden Daten-Seiten stammen.%0a%0aEs gibt zwei Wege, die angepassten Kriterien für die Seitenlistenreihenfolge zu erzeugen.%0a%0a!!Methode 1%0a%0aWenn die gewünschte Sortierreihenfolge @@$:Year,$:Work,$:Author@@ ist, benutzen wir '@@yearworkauthor@@' als unseren eigenen Parameter für die Sortierfunktion, so dass das Seitenlistenkriterium so aussieht:%0a->%25pmhlt%25[@ (:pagelist order=yearworkauthor:) @]%0a%0aDas Array, das die ''order=''-Parameter auf die angepassten Sortierfunktionen abbildet, die dafür aufgerufen werden sollen, ist @@$PageListSortCmp@@:%0a%0a-->%25hlt php%25[@$PageListSortCmp['yearworkauthor'] = 'YearWorkAuthor';@] # nur der Funktionsname (empfohlen)%0aoder früher%0a-->%25color=#888%25[@$PageListSortCmp['yearworkauthor'] = 'YearWorkAuthor($x, $y)';@] %25%25# überholt seit PHP 7.2%0a%0a@@$PageListSortCmp@@ ist ein Array von Seitenlistenfunktionen. Jede gelistete Funktion (nach dem =) erwartet zwei Parameter &ndash; jeder Parameter enthält den Seitennamen für eine der Seiten, die sortiert werden sollen, es werden immer nur zwei Seiten miteinander verglichen. Das heißt, um einen Vergleich zwischen zwei Seiten in der Seitenliste durchzuführen (die durch @@$x@@ und @@$y@@ gegeben sind), rufe die Funktion %25hlt php%25@@YearWorkAuthor()@@ auf und übergib die beiden Seitennamen als Argumente. %0a%0aDie %25hlt php%25@@YearWorkAuthor()@@%25%25-Funktion gibt einen Wert kleiner als Null zurück, wenn @@$x@@ in der Liste vor @@$y@@ erscheinen soll, größer als null, wenn @@$x@@ nach @@$y@@ erscheinen soll und null, wenn beide Namen 'gleichwertig' im Sinne der Sortierung sind.%0a%0aNatürlich enthalten in diesem Szenario die Seiten, die durch @@$x@@ und @@$y@@ gegeben sind, nicht die Werte, nach denen wir sortieren wollten &ndash; jene Werte sind in den korrespondierenden "@@Daten-*@@"-Seiten von @@$x@@ und @@$y@@ &ndash;, sonst müssten wir die Sortierung nicht anpassen. Darum suchen wir nach den korrespondierenden "@@Daten-@@"-Seiten und vergleichen die Seitentext-Variablen aus diesen Seiten:%0a%0a->%25hlt php%25[@function YearWorkAuthor($x, $y) {%0a      ## zuerst holen wir die "Daten-"-Version der Seitennamen%0a      $datax = 'Daten-' . PageVar($x, '$BaseName');%0a      $datay = 'Daten-' . PageVar($y, '$BaseName');%0a%0a      ## vergleiche die $:Year-Werte %0a      $c = strcmp(PageVar($datax, '$:Year'), PageVar($datay, '$:Year'));%0a      if ($c != 0) return $c;%0a%0a      ## vergleiche die $:Work-Werte %0a      $c = strcmp(PageVar($datax, '$:Work'), PageVar($datay, '$:Work'));%0a      if ($c != 0) return $c;%0a%0a      ## vergleiche die $:Author-Werte%0a      $c = strcmp(PageVar($datax, '$:Author'), PageVar($datay, '$:Author'));%0a      return $c;%0a}@]%0a%0aIn der obigen Funktion finden die ersten beiden Zeilen den Namen der korrespondierenden "@@Daten-*@@"-Seiten von @@$x@@ und @@$y@@ heraus und speichern sie in @@$datax@@ und @@$datay@@. Die nächsten zwei Zeilen holen die @@$:Year@@-Seitentext-Variablen aus @@$datax@@ und @@$datay@@ und geben einen positiven oder negativen Wert zurück, wenn sie verschieden sind. "%25hlt php%25@@strcmp()@@" ist eine eingebaute PHP-Funktion ("string compare", Stringvergleich), und die gibt einen numerischen Wert zurück, der aussagt, wie verschieden zwei Datenteile (Text) sind. Wenn sie gleich sind (d. h. @@$c == 0@@), fallen wir durch zum Test der @@$:Work@@-Seitentext-Variablen mit der gleiche Logik, und wenn auch die gleich sind, testen wir die @@$:Author@@-Seitentext-Variablen und geben das Ergebnis zurück.%0a%0aSo wie die Funktion geschrieben ist, gibt es ein kleines bisschen Overhead durch den wiederholten Aufruf von %25hlt php%25@@PageVar()@@, den wir vermeiden könnten, wenn Geschwindigkeit eine Rolle spielt, aber der obige Kode illustriert das Basiskonzept hinter der angepassten Sortierung.%0a%0a%0a!!Methode 2%0a%0aUm den Wikibenutzern mehr Flexibilität zu geben, ist eine andere Annäherung, zunächst eine generische %25hlt php%25@@DataCompare()@@-Funktion für den Vergleich von Seitentext-Variablen in "Daten-*"-Seiten zu erstellen, und dann getrennte "year"-, "work"-, und "author"-Optionen für den "@@order=@@"-Parameter zu definieren, die ein passendes Argument an %25hlt php%25@@DataCompare()@@ übergeben.%0a%0a-->%25hlt php%25[@function DataCompare($x, $y, $order) {%0a      $var = "$:" . ucfirst($order); # year -> $:Year%0a      ## hole zuerst die "Daten-"-Version der Seitennamen,%0a      $datax = 'Daten-' . PageVar($x, '$BaseName');%0a      $datay = 'Daten-' . PageVar($y, '$BaseName');%0a%0a      ## führe dann den geforderten Vergleich durch.%0a      $c = strcmp(PageVar($datax, $var), PageVar($datay, $var));%0a      return $c;%0a}%0a%0a$PageListSortCmp['year']    = 'DataCompare';%0a$PageListSortCmp['work']    = 'DataCompare';%0a$PageListSortCmp['author']  = 'DataCompare';%0a@]%0a%0aBeachten Sie, der folgende Kode war früher gültig, wird aber Deprecated-Warnungen in PHP 7.2 erzeugen. Siehe oben für ein Update.%0a>>color=#888%3c%3c%0a-->[@function DataCompare($x, $y, $var) {%0a      ## hole zuerst die "Daten-"-Version der Seitennamen,%0a      $datax = 'Daten-' . PageVar($x, '$BaseName');%0a      $datay = 'Daten-' . PageVar($y, '$BaseName');%0a%0a      ## führe dann den geforderten Vergleich durch.%0a      $c = strcmp(PageVar($datax, $var), PageVar($datay, $var));%0a      return $c;%0a}%0a%0a$PageListSortCmp['year']   = 'DataCompare($x, $y, "$:Year")';%0a$PageListSortCmp['work']   = 'DataCompare($x, $y, "$:Work")';%0a$PageListSortCmp['author'] = 'DataCompare($x, $y, "$:Author")';%0a@]%0a>>%3c%3c%0a%0a %0aDann können Sie jede Menge an Seitenlisten-"order="-Kombinationen wählen wie:%0a%0a->%25hlt php%25[@order=year           # sortieren nach $:Year aus den "Daten-*"-Seiten%0aorder=year,work      # sortieren nach $:Year, dann nach $:Work%0aorder=year,-author  # sortieren nach $:Year, dann rückwärts nach $:Author%0aorder=author        # sortieren nur nach $:Author%0a@]%0a%0a%0aDas ist näher dran an dem, was ein Autor erwarten würde, weil andere Sortierkriterien vom Benutzer geformt und verschachtelt werden können. Wenn Sie Ihre Benutzer in die Lage versetzen wollen, die Sortierreihenfolge anzupassen, ohne dass Sie eine Neuprogrammierung in der ''@@config.php@@'' wegen neuer Anforderungen durchführen müssen, ist dies möglicherweise die bessere Methode. %0a%0a!!![[#alternative]]Alternativer Weg%0a%0aBerücksichtigen Sie, dass Seiten-Variablen der generelle PmWiki-Aufhänger sind (oder sein sollten), um angepasste Dinge mit den Attributen und Eigenschaften von Seiten zu machen.%0a%0aTatsächlich ist hier ein *weiterer* Weg, das Sortieren/Gruppen/Anzeigen-Problem zu behandeln, indem angepasste Seiten-Variablen definiert werden, die genau das Erwünschte haben, ohne dass irgendein benutzerdefiniertes Sortierfeature für %25pmhlt%25[@(:pagelist:)@] definiert werden müsste.%0a%0aLassen Sie uns @@$Year@@-, @@$Work@@- und @@$Author@@-Seiten-Variablen für jede Seite so definieren, dass die Werte von @@$Year@@, @@$Work@@, und @@$Author@@ für jede Gruppe.XYZ-Seite immer die @@$:Year@@-, @@$:Work@@-, und @@$:Author@@-Seitentext-Variablen von @@Gruppe.XYZ@@s korrespondierender "@@Daten-*@@"-Seite sind. Mit anderen Worten, %25pmhlt%25[@{$Year}@] für jede Seite wird immer so funktionieren, als hätten Sie [@{Daten-{$BaseName}$:Year}@] angegeben.  %0a%0aHier folgen die Definitionen:%0a%0a->%25hlt php%25[@$FmtPV['$Year'] =%0a  "PageTextVar('Daten-'.MakeBaseName(\$pn), 'Year')";%0a%0a$FmtPV['$Work'] =%0a  "PageTextVar('Daten-'.MakeBaseName(\$pn), 'Work')";%0a%0a$FmtPV['$Author'] =%0a  "PageTextVar('Daten-'.MakeBaseName(\$pn), 'Author')";@]%0a%0aTja, was haben wir jetzt davon? Nun, der Wert von %25pmhlt%25[@{$Year}@] ist immer der Wert von [@{$:Year}@] der korrespondierenden "@@Daten-@@"-Seite. Dadurch gibt %25pmhlt%25[@{Gruppe.Steinbeck$Year}@] immer den Wert von [@{Daten-Gruppe.Steinbeck$Year}@] zurück. Darüber hinaus funktioniert das sogar, wenn die aktuelle Seite im Daten-Bereich ist &ndash; d. h., der Wert von %25pmhlt%25[@{Daten-Gruppe.Steinbeck$Year}@] ist der gleiche wie [@{Daten-Gruppe.Steinbeck$:Year}@]. (Die erste ist eine Seiten-Variable, die zweite ist eine Seitentext-Variable.)%0a%0aWas wir damit getan haben ist die Verlagerung aller Ergebnisse der den" @@Daten-@@"-Seiten entsprechenden%0aSeiten aus den Seitenlistenvorlagen in einige%0arelativ einfache Definitionen von Seiten-Variablen. Damit sehen unsere %0aSeitenlisten-Direktiven so aus:%0a%0a->%25pmhlt%25[@(:pagelist group=Gruppe order=$Year,$Work,$Author:)%0a(:pagelist group=Daten-Gruppe order=$Year,$Work,$Author:)%0a@]%0a%0aDie Angabe von order@@=$Year,$Work,$Author@@ (Seiten-Variablen) bedeutet,%0adass wir die Seitenlisten auf der Basis der @@$:Year@@-, @@$:Work@@-, und @@$:Author@@-Seitentext-Variablen der korrespondierenden Seiten in der Gruppe Daten-Gruppe sortieren.%0a%0aBeachten Sie, dass wir uns auch keine Sorgen darum machen müssen, ob die Seitenliste durch die Gruppe selbst oder die entsprechende "Daten-*"-Gruppe läuft, da unsere angepassten Seiten-Variablen immer die Seitennamen auf die "@@Daten-@@"-Form der Gruppen abbildet.%0a%0aDas vereinfacht die Seitenlisten-Vorlage, denn wir können nun einfach schreiben:%0a%0a->%25pmhlt%25[@(:if ! equal {%3c$Year} {=$Year}:)%0a!! {=$Year}%0a(:ifend:)@]%0a  %0aNochmal, die '@@$Year@@'-Seiten-Variable achtet selbst auf die Details%0abei der Beschaffung von @@$:Year@@ aus der korrekten [@Daten-{$BaseName}@]-Seite,%0aanstatt zu versuchen, die Auswertung durch das Markup vorzunehmen. %0a%0a!! Siehe auch%0a* $PageListSortCmpFunction%0a* Cookbook:CustomPagelistSortOrderFunctions - [-{Cookbook.CustomPagelistSortOrderFunctions$:Summary} (angepasste Funktionen zum Erstellen von angepassten Sortierreihenfolgen bei Seitenlisten, englisch)-]%0a%0a%0a
time=1660984844
title=Angepasste Seitenlistenreihenfolge
