version=pmwiki-2.3.16 ordered=1 urlencoded=1
author=MFWolff
charset=UTF-8
csum=add to markup category (+35)
name=PmWikiDe.CustomMarkup
rev=50
targets=PmWikiDe.PageTextVariables,PmWikiDe.CustomMarkup,PmWikiDe.DebugVariables,PmWikiDe.LocalCustomizations,Cookbook.Cookbook,Cookbook.ParseArgs,PmWiki.ReleaseNotes,PmWikiDe.Functions,PmWikiDe.BasicVariables,PmWiki.CustomMarkup-Talk,PmWiki.MailingLists,Cookbook.JavaScript,Cookbook.JavaScript-Editable,PmWikiDe.Skins,PmWikiDe.LayoutVariables,PmWikiDe.CustomMarkupAlt,Category.Markup,!Markup
text=(:title Eigene Auszeichnungen:)%0a(:Summary: Gebrauch der Markup()-Funktion zur Erzeugung eigener Formatierungsanweisungen, Übergang zu PHP 5.5:)%0a(:Original_Page: PmWiki.CustomMarkup:)%0a(:Translation_Date: 2014-04-02:)%0a(:Translation_Status: %25green%25fertig%25%25:)%0a(:Audience: Administratoren (FTP):)%0a%0aDie Auszeichnungsumwandlung wird bei PmWiki durch einen Satz von Regeln gesteuert. Jede Regel definiert eine bestimmte Zeichenkette, nach der der Wikitext durchsucht wird. Die gefundene Stelle wird durch einen anderen Text ersetzt. Intern wird das mit der PHP-Funktion "[[(http://www.php.net/de/)preg_replace]]" verwirklicht.%0a%0a!! Einführung%0a%0aZusätzliche Regeln werden der Übersetzungsmaschine in PmWiki mit der PmWiki-Funktion %25hlt php%25@@Markup()@@ bekannt gemacht. Diese sehen folgendermaßen aus:%0a%0a->%25hlt php%25[@Markup($name, $wann, $muster, $ersetzung); @], wenn keine Evaluation nötig ist oder wenn PHP %3c 5.5%0a->%25hlt php%25[@Markup($name, $wann, $muster, $ersetzungs_funktion); @], wenn Evaluation nötig ist%0a%0a** [@$name@] ist ein eindeutiger Name (Zeichenfolge) für die Regel,%0a** [@$wann@] legt fest, wann die Regel im Vergleich zu den anderen Regeln ausgeführt werden soll,%0a** [@$muster@] enthält das Suchmuster, nach dem im Markuptext (dem Wikiquelltext) gesucht wird, %0a** [@$ersetzung@] ist die Zeichenfolge, durch die das gefundene Muster ersetzt werden soll und%0a** [@$ersetzungs_funktion@] ist der Name der Funktion, die mit dem Übereinstimmungen-Array aufgerufen wird und die die Ersetzung zurückliefern soll.%0a%0a->%25red%25# '''missbilligt'''%25%25, wird ab PHP 7.2 nicht mehr funktionieren%0a->{-Markup_e($name, $wann, $muster, $ersetzung); # wenn Evaluation nötig ist und 5.5 %3c= PHP %3c= 7.1-}%0a%0a!!! Beispiel%0aAls Beispiel hier der Programmcode, der die Regel für [@''hervorgehobener Text''@] (in ''scripts/stdmarkup.php'') erzeugt:%0a%0a->%25hlt php%25[@Markup("em", "inline", "/''(.*?)''/", "%3cem>$1%3c/em>");@]%0a%0aDiese Anweisung erstellt eine Regel, die "em" heißt, welche zusammen mit anderen "inline" Auszeichnungen ausgeführt wird. Die Regel ersetzt den Text innerhalb zweier Paare einfacher Anführungszeichen durch eben diesen Text ($1), jedoch eingeschlossen von %25hlt html%25[@%3cem>@] und [@%3c/em>@].%0a%0a!!!! Name und Reihenfolge%0aDie ersten beiden Parameter von %25hlt php%25@@Markup()@@ legen die Reihenfolge der Anwendung der Regeln fest. Der erste Parameter gibt der Regel einen Namen &ndash; "[@em@]" im obigen Beispiel. Man könnte einen beliebigen anderen Namen benutzen, etwa "[@''@]" oder sogar "[@zweieinfachehochkommata@]". Im Allgemeinen benutzt PmWiki das Markup selbst als Namen der Regel (d.h. PmWiki würde "[@''@]" und nicht "[@em@]" benutzen), aber im Interesse der Lesbarkeit im Folgenden benutzen wir hier einen mnemonischen Namen.%0a%0aDer zweite Parameter sagt, dass die Regel zusammen mit anderen "inline" Auszeichnungen bearbeitet werden soll. PmWiki teilt den Übersetzungsvorgang in mehreren Phasen auf:%0a%0a%0a  _begin      Beginn der Umwandlung%0a  [={$var}=]      Verarbeitung der [[page text variables|+]]%0a  fulltext    Verarbeitung des gesamten Eingabetextes%0a  split       Zerteilen des Eingabetextes in einzelne, zu verarbeitende Zeilen%0a  directives  Verarbeitung von Direktiven%0a  inline      Übersetzung von im Text auftauchenden Auszeichnungen%0a  links       Übersetzung von Verweisen, Internetadressen und Wikiwörtern%0a  block       Übersetzung von Block-Auszeichnungen%0a  style       Umsetzung von Stilen%0a  _end        Ende der Umwandlung%0a%0a%0aDies Argument wird normalerweise als öffnende spitze Klammer "%3c" ("vorher") oder schließende spitze Klammer ">" ("nachher") angegeben, gefolgt vom Namen einer anderen Regel.%0a %0aDie Angabe "inline" als zweiter Parameter bedeutet somit, dass die Regel zusammen mit anderen "inline" Regeln verarbeitet wird. Soll die Regel dagegen zusammen mit den Direktiven verarbeitet werden, d.&nbsp;h. bevor die inline-Regeln verarbeitet werden, müsste man "directives" oder "%3cinline" als zweiten Parameter angeben.%0a%0a!!!! [={$var}=]- und [=(:if ...:)=]-Bedingungen%0aEine signifikante Regel in Sachen Reihenfolge ist "[@{$var}@]", wo Variablen ersetzt werden &ndash; wenn es heißt "[@%3c{$var}@]", dann wird Ihr Markup bearbeitet, ''bevor'' Variablen ersetzt werden, wohingegen "[@>{$var}@]" bedeutet, dass Ihr Markup bearbeitet wird, ''nachdem'' die Variablen ersetzt wurden. Das passiert noch vor Bedingungsausdrücken %25pmhlt%25[@(:if...:)@], weshalb Seitentextvariablen ausgewertet werden, selbst wenn sie innerhalb eines [@(:if false:)@]-Segments definiert wurden.%0a%0a!!!! Definition des regulären Ausdrucks im Markup%0aDer dritte Parameter ist ein Perl-kompatibler regulärer Ausdruck. Genau genommen ist es ein Schrägstrich, ein [[regulärer Ausdruck  -> http://www.php.net/manual/de/reference.pcre.pattern.syntax.php]], ein weiterer Schrägstrich und (optional) einige [[Modifikatoren -> http://www.php.net/manual/de/reference.pcre.pattern.modifiers.php]].%0a%0aDas Beispiel verwendet das Suchmuster [@"/''(.*?)''/"@], das [@''(.*?)''@] als regulären Ausdruck ohne weitere Optionen enthält. (Der reguläre Ausdruck sagt: "Finde zwei aufeinander folgende einfache Anführungszeichen, dann so wenig beliebige Zeichen wie möglich, damit das Suchmuster zutrifft, danach wieder zwei aufeinander folgende einfache Anführungszeichen". Die Klammern "kopieren" einen Teil des Wikitextes für die spätere Verwendung in eine "Zwischenablage".)%0a%0a!!!! Ersetzungstext%0aDer vierte Parameter ist der Ersetzungstext, der anstatt des kompletten Suchmusters (Auszeichnung und Wikitext) angezeigt werden soll. Man kann [@$1@], [@$2@] usw. verwenden, um den Text aus dem ersten, zweiten usw. geklammerten Bereich innerhalb des Textes im regulären Ausdruck einzufügen.%0a%0aIn diesem Beispiel wird %25hlt html%25[@"%3cem>$1%3c/em>"@] verwendet, das aus [@%3cem>@], dem gefundenen Text innerhalb der ersten Klammer (d.h. den Teil [@.*?@] des Musters) und [@%3c/em>@] besteht.%0a%0a!!!Weitere Beispiele %0a%0aHier die Regel für %25pmhlt%25[@@@Schreibmaschinenschrift@@@]:%0a%0a->%25hlt php%25[@Markup("@@", "inline", "/@@(.*?)@@/", "%3ccode>$1%3c/code>");@]%0a%0aund für eine [@[:comment ...:]@]-Direktive, die einfach bei der Ausgabe entfernt wird:%0a%0a->%25hlt php%25[@Markup("comment", "directives", "/\\[:comment .*?:\\]/", '');@]%0a%0aAber wie funktioniert das bei der %25pmhlt%25[@'''starken Hervorhebung'''@]?  Hier muss man etwas vorsichtig sein. Zwar wird diese zusammen mit andere Inline-Auzeichnungen bearbeitet, aber es muss auch sichergestellt werden, dass die Regel [@'''@] ''vor'' der Regel [@''@] bearbeitet wird, da [@'''@] auch  [@''@] enthält. Der zweite Parameter von  %25hlt php%25@@Markup()@@ kann auch benutzt werden, um die Beziehung einer Regel zu einer anderen festzulegen:%0a%0a->%25hlt php%25[@Markup("strong", "%3cem", "/'''(.*?)'''/", "%3cstrong>$1%3c/strong>");@]%0a%0aDies erzeugt eine Regel mit Namen "strong" und der zweite Parameter "%3cem" legt fest, dass die Regel ''vor'' der weiter oben gezeigten "em"-Regel verarbeitet werden soll. Um etwas nach der "em"-Regel auszuführen, würde man stattdessen ">em" verwenden. Damit ist es möglich, Erweiterungen an jeder Stelle der Umwandlung von Auszeichnungen vorzunehmen. (Genau genommen sind "inline", "block", "directives" usw. nur Platzhalter um den Gesamtablauf zu strukturieren, sodass andere Regeln an passender Stelle eingefügt werden können. So kann etwa "%3cinline" benutzt werden, damit eine Regel vor anderen "inline" Regeln angewendet wird.)%0a%0aWenn Sie verfügbare Auszeichnungen abschalten wollen, schreiben sie einfach z.&nbsp;B.:%0a%0a->%25hlt php%25[@DisableMarkup("strong");@]%0a%0aDie vordefinierten Auszeichnungen von PmWiki sind in ''scripts/stdmarkup.php'' definiert. Um die gesamte Ersetzungstabelle während der Programmausführung auszugeben, gibt es das Modul scripts/diag.php das die Aktion "[@?action=ruleset@]" zur Verfügung stellt. Damit werden die festgelegten Regeln in der Reihenfolge angezeigt, in der sie verarbeitet werden.  Man sieht dies z.&nbsp;B. in [[CustomMarkup?action=ruleset|Eigene Auszeichnungen?action=ruleset]]. Sie müssen vorher die Aktion aktivieren durch das Einstellen von $EnableDiag = 1 in Ihrer Konfigurationsdatei. %0a%0a!! @@%3c:vspace>@@ und @@%3c:block>@@%0a@@%3c:vspace>@@ wird sehr früh während der Seitentextverarbeitung eingefügt, um eine leere Zeile zu schützen (d.&nbsp;h. zwei aufeinanderfolgende Leerzeilen). Sehr spät im Prozess wird HTML in die Seitenausgabe eingefügt, um die leere Zeile zu erhalten. %0aWenn die Markup-Behandlung das nicht entdeckt, kann es ignoriert werden.%0a%0a@@%3c:block>@@\\%0aAm Zeilenanfang bedeutet @@%3c:block>@@ "starte ein 'block-level element'",%0ad.&nbsp;h. brich aus den Absätzen aus.%0a%0aSagen wir, Sie haben diese Markups:%0a* (:abc:) gibt 'ABC' zurück%0a* (:def:) gibt '%3c:block>DEF' zurück%0a%0aDann wird dieser Wikitext:%0a Etwas Text%0a (:abc:)%0a mehr Text%0a%0adiesen HTML-Text erzeugen (vereinfacht):%0a %3cp>Etwas Text%0a ABC%0a mehr Text%3c/p>%0a%0aWährend dieser Text:%0a Etwas Text%0a (:def:)%0a mehr Text%0a%0adiesen HTML-Text erzeugen wird (vereinfacht):%0a %3cp>Etwas Text%3c/p>%0a DEF%0a %3cp>mehr Text%3c/p>%0a%0aDies ist für eine Markup-Regel vorgesehen, die eine BlockLevel-Element wie %3cdiv>...%3c/div> zurückgibt, dass in einem HTML-Absatz nicht erlaubt ist.%0a%0a!! Weitere gängige Beispiele%0a%0a!!! Definieren einer eigenen Funktion, die eine spezielle HTML- oder Javascript-Sequenz erzeugt%0a%0aAngenommen, ein Admin möchte eine einfache "[@(:example:)@]"-Auszeichnung haben, die immer eine feste HTML-Zeichenkette in der Ausgabe erzeugt, etwa für einen Webring, Google-AdSense-Display oder Javascript. Der %25hlt php%25@@Markup()@@-Aufruf, der das bewirkt, wäre  %0a%0a->%25hlt php%25[@%0aMarkup('example', 'directives',%0a  '/\\(:example:\\)/',%0a  Keep("%3cdiv class='example'>%3cp>Here is a %0a    %3ca target='_blank' href='http://www.example.com'>link%3c/a> to%0a    %3cem>example.com%3c/em>%3c/p>%3c/div>") );%0a@]%0a%0a* Das erste Argument ist ein einzigartiger Name für die Auszeichnung ("example").%0a* Das zweite Argument sagt, führe diese Auszeichnung zusammen mit anderen Direktiven durch.%0a* Das dritte Argument ist das Suchmuster "(:example:)".%0a* Das vierte Argument ist die HTML-Zeichenkette, durch die "(:example:)" ersetzt wird. Wir benutzen hier die %25hlt php%25@@Keep()@@-Funktion, um die Ausgabe davor zu schützen, von nachfolgenden Regeln bearbeitet zu werden &ndash; im obigen Beispiel wollen wir nicht, dass der [[http://www.example.com]][=-=]URL wieder in einen Link verwandelt wird.%0a%0a[[#random]]%0a!!!Aufruf einer eigenen Funktion, die etwas zurück liefert%0a%0a->%25red%25 Der /e-Modifizierer ist überholt und sollte in aktuellen Entwicklungen nicht eingesetzt werden. Siehe [[#php55|unten]] wegen weiterer Details.%25%25%0a%0aFür ältere PHP-Versionen (%3c 7.2) veranlasst die 'e'-Option beim Parameter [@$muster@]  PmWiki, den Parameter [@$ersetzung@] nicht als Ersetzungstext, sondern als PHP-Ausdruck zu interpretieren, der den Ersetzungsausdruck zurückliefert. Um den Gebrauch des missbilligten 'e'-Parameters zu vermeiden, sähe ein Markup, das eine Zahl zwischen 1 und 100 liefert, so aus:%0a%0a->%25hlt php%25[@%0aMarkup('random', 'directives',%0a  '/\\(:random:\\)/',%0a  "MyRandomFunction");%0afunction MyRandomFunction() {%0a  return rand(1, 100);%0a}%0a@]%0a%0aDies ruft die PHP-interne %25hlt php%25@@rand()@@-Funktion auf und ersetzt die Direktive mit dem Ergebnis. Jede Funktion kann aufgerufen werden, einschließlich der Funktionen, die in einer Datei für [[LocalCustomizations|+]] oder in einem [[Cookbook:Cookbook|Kochbuch]][=-=]Rezept definiert wurden. %0a%0aArgumente können auch übergeben werden, indem reguläre Ausdrücke einfangende Klammern benutzt werden, so bewirkt die Auszeichnung %0a %0a->%25hlt php%25[@%0aMarkup('randomargs', 'directives',%0a  '/\\(:random (\\d+) (\\d+):\\)/',%0a  "MyRandomFunction");%0afunction MyRandomFunction($m) {%0a  return rand($m[1], $m[2]);%0a}@],%0a%0adass die Direktive %25pmhlt%25[@(:random 50 100:)@] eine Zufallszahl zwischen 50 und 100 erzeugt. %0a%0a->%25note%25 Beachten Sie: Der 'e'-Modifizierer in regulären Ausdrücken ist seit PHP Version 5.5 verpönt und ab PHP Version 7 entfernt. Der Grund ist, dass  arglistige Autoren in der Lage sein könnten, Zeichenketten zu übergeben, die die Ausführung eigenmächtiger und unerwünschter Funktionen bewirkt. %25%25%0a%0aWegen einer PmWiki-Funktion, die hilft, beliebige Sequenzen aus Schlüssel-Wert-Paaren zu parsen, siehe Cookbook:ParseArgs.%0a%0a[[#php55]]%0a!! Migration zu PHP 5.5 und @@Markup_e()@@%0a%0aSeit PHP Version 5.5 wird der @@/e@@-Auswertungs-Modifier missbilligt und einige Hoster erlauben seine Verwendung nicht mehr. %0a%0aJüngere [[PmWiki:ReleaseNotes|Versionen]] des PmWiki-Kerns (2.2.58 und jünger) erlauben neue Wege, um Auszeichnungsregeln zu definieren, ohne auf den Modifier @@/e@@ zurückgreifen zu müssen. Die historischen Wege, Auszeichnungsregeln zu definieren, wurden nicht entfernt und laufen weiterhin, aber sie könnten mit PHP-5.5-Installationen unverträglich sein. %0a%0a''Beachten Sie: Wenn ihr Ersatzmuster nicht ausgewertet werden muss, sollten Sie %25hlt php%25@@Markup()@@%25%25 benutzen wie bisher und %25red%25nicht @@Markup_e()@@%25%25.'' Das letztere ist verpönt und sollte nicht länger für neue Rezepte und Anpassungen verwendet werden. Alte Rezepte, die @@Markup_e@@ verwenden, sollten aufgebessert werden und das neue Format benutzen.%0a%0aDie folgenden Beispiele erfordern alle PmWiki 2.2.58 (2013-12-25) oder neuer, allerdings wird die letzte Version empfohlen.%0a %0a>>frame%3c%3c%0aDIE KURZFASSUNG: Wenn der reguläre Ausdruck Ihres Markups (das dritte Argument) ein "e" hinter dem schließenden Schrägstrich (d.&nbsp;h. @@/regex/e@@ oder @@/regex/se@@ oder entsprechendes) UND Ihr viertes Argument ist vollständig umgeben von doppelten Anführungszeichen, dann kommen Sie aus der Sachen raus, indem Sie einfach die folgenden simplen Schritte unternehmen:%0a%0a# Löschen Sie das "e" in den dritten Argument hinter dem Schrägstrich.%0a# Erzeugen Sie eine Ersetzungsfunktion mit $m als Argument.%0a# In Ihrer Funktion finden sich die ursprünglichen Vorkommen von '$1', '$2', etc. als '$m[1] '$m[2]', etc. wieder. Sie sollten @@[[Functions#PSS|PSS()]]@@ nicht mehr aufrufen.%0a# Rufen Sie in Ihrer Funktion %25hlt php%25@@extract($GLOBALS['MarkupToHTML']);@@ auf, um den aktuellen $pagename und die @@$markupid@@ zu erhalten. %0a# Ihre Funktion muss das Ergebnis des Markup-Prozesses zurückliefern, entweder HTML oder ein anderes Markup.%0a# Setzen Sie den Namen Ihrer Ersetzungsfunktion als viertes Argument des @@Markup()@@-Aufrufs ein.%0a%0aIn manchen Fällen reicht das nicht aus &ndash; das hängt davon ab, wie das Anführen gemacht wird &ndash; aber in vielen Fällen wird das Befolgen dieser einfachen Schritte zu der Verträglichkeit mit PHP 5.5+ führen.%0a%0aWenn Sie diese Schritte befolgt haben und dennoch Probleme haben, dann fahren Sie fort zu lesen für ein tieferes Verständnis.%0a>>%3c%3c%0a%0aDas Folgende ist akzeptabel für PHP 5.5+ (verträglich mit PmWiki 2.2.58+, läuft auch mit PHP 5.4 und älter)%0a* %25hlt php%25@@Markup($name, $wann, $muster, $ersetzung)@@;%0a** @@$muster@@ darf keinen "@@/e@@"-Modifizierer mehr enthalten%0a** @@$ersetzung@@ kann eine Zeichenkette mit Übereinstimmungen wie $1, $2 etc. sein,%0a** @@$ersetzung@@ kann der Name einer Funktion sein (callback), die mit dem Array der Übereinstimmungen als Argument aufgerufen wird.%0a** Anstelle einer Zeichenkette kann der vierte Parameter auch eine anonyme Funktion sein (Beachten Sie: Sie können anonyme Funktionen auf diese Weise seit [[http://php.net/manual/en/functions.anonymous.php  | PHP 5.3.0+]] benutzen)%0a** Für PHP 5.4 oder früher kann $muster einen /e-Modifier enthalten. %0a %0a* @@Markup_e($name, $wann, $muster, $ersetzung)@@; %25red%25 VERPÖNT, sollte nicht länger eingesetzt werden%0a%0aBeispiele:%0a%0a* Für PHP 5.4 und älter war dies akzeptabel:%25hlt php%25[@%0aMarkup('randomargs', 'directives',%0a  '/\\(:random (\\d+) (\\d+):\\)/e',%0a  "rand('$1', '$2')"%0a  );@]%0a%0a* Für PHP 5.5 und jünger ist $ersetzung der Name einer (callback-) Funktion, wir rufen markup() auf: %25hlt php%25[@%0aMarkup('randomargs', 'directives',%0a  '/\\(:random (\\d+) (\\d+):\\)/',%0a  "MyRandom"%0a  );%0afunction MyRandom($m) { #$m = matches%0a  return rand($m[1], $m[2]); # Merke: "return" wird benutzt, anders als vorher%0a}%0a@]%0a->%25note%25 Das läuft auch unter PHP 5.4 und älter.%25%25%0a%0a%0aEin weiteres Beispiel:%0a* PHP 5.4 oder älter: %25hlt php%25[@%0aMarkup('Maxi:','%3clinks',%0a  "/\\b([Mm]axi:)([^\\s\"\\|\\[\\]]+)(\"([^\"]*)\")?/e",%0a  "Keep(LinkMaxi(\$pagename,'$1','$2','$4','$1$2'),'L')"%0a  );%0a@]%0a%0a* PHP 5.5 oder neuer, PmWiki 2.2.58+, $ersetzung ist der Name einer Funktion: %25hlt php%25[@%0aMarkup('Maxi:','%3clinks',%0a  "/\\b([Mm]axi:)([^\\s\"\\|\\[\\]]+)(\"([^\"]*)\")?/",%0a  "LinkMaxi"%0a  );%0afunction LinkMaxi($m) {%0a  extract($GLOBALS['MarkupToHTML']); # to get $pagename%0a  # do stuff with $m[1], $m[2], etc.%0a  return Keep($out, 'L');%0a}%0a@]%0a->%25note%25 Das läuft auch unter PHP 5.4 und älter.%25%25%0a%0a* $ersetzung kann auch eine callback-Funktion sein, wir rufen  %25hlt php%25@@Markup()@@ auf:[@%0aMarkup('Maxi:','%3clinks',%0a  "/\\b([Mm]axi:)([^\\s\"\\|\\[\\]]+)(\"([^\"]*)\")?/",%0a  "CallbackMaxi"%0a);%0afunction CallbackMaxi($m) {%0a  extract($GLOBALS["MarkupToHTML"]); # to get $pagename%0a  return Keep(LinkMaxi($pagename,$m[1],$m[2],$m[4],$m[1].$m[2]),'L');%0a}%0a@]%0a->%25note%25 Das läuft auch unter PHP 5.4 und älter.%25%25%0a%0aDas Obige mag kompliziert erscheinen, aber es ist tatsächlich einfacher, Sie benutzen ihre eigene callback-Funktion.%0a-> %25hlt php%25[@%0aMarkup('mykey', 'directives', %0a  '/\\(:mydirective (.*?) (.*?):\\)/i',%0a  'MyFunction'%0a);%0afunction MyFunction($m) {%0a  extract($GLOBALS["MarkupToHTML"]);%0a%0a  # ... do stuff with $m (the matches), drop PSS() ...%0a%0a  return $out; # oder return Keep($html);%0a}%0a@]%0a%0a%0aWenn Sie irgendwelche Fragen haben bezüglich des neuen Weges, mit dem man eigene Markup-Funktionen definiert, fragen Sie uns %0a[[PmWiki:CustomMarkup-Talk|auf der Talk-Seite]] oder den [[PmWiki/mailing lists|Mailinglisten]].%0a%0a%0a!!FAQ%0a>>faq%3c%3c [[#faq]]%0aQ: Wie kann ich JavaScript in die Ausgabe einer Seite einfügen?%0aA: Es gibt mehrere Wege, das zu erreichen. Das [[Cookbook:JavaScript]]-Rezept beschreibt ein einfaches Verfahren, um statisches JavaScript in eine Webseite einzufügen mit Hilfe von [[custom markup|eigenen Auszeichnungen]]. Um JavaScript direkt in Wikiseiten zu schreiben (was verschiedene Sicherheitsrisiken öffnen kann), siehe das [[(Cookbook:)JavaScript-Editable]]-Rezept. Für JavaScript, das im Kopf- und Fußbereich von Seiten erscheinen soll, können Sie die [[skin(s)]]-Vorlage direkt verändern, oder Sie fügen %3cscript>-Anweisungen ein, indem Sie das $HTMLHeaderFmt-Array benutzen.%0a%0aQ: Wie erstelle ich ein Markup %25pmhlt%25(''[@(:nodiscussion:)@]''), das eine Seitenvariable (''[@{$HideDiscussion}@]'') setzt, die wiederum mit ''[@(:if enabled HideDiscussion:)@]'' in [=.PageActions=]? eingesetzt werden kann? %0aA: Fügen Sie den folgenden Kodeabschnitt in Ihre ''config.php'' ein:%0a-> %25hlt php%25[@%0aSDV($HideDiscussion, 0); 	#define var name%0aMarkup('hideDiscussion', '%3c{$var}',%0a '/\\(:nodiscussion:\\)/', 'setHideDiscussion'); %0afunction setHideDiscussion() { %0a  global $HideDiscussion; %0a  $HideDiscussion = true;%0a} %0a@]%0a%0aDas macht es möglich, die %25pmhlt%25@@[=(:if enabled HideDiscussion:)=]@@-Auszeichnung einzusetzen. Wenn Sie den aktuellen Wert von [={$HideDiscussion}=] auf der Seite anzeigen wollen (für Testzwecke), müssen Sie auch die Zeile%0a-->%25hlt php%25@@[=$FmtPV['$HideDiscussion'] = '$GLOBALS["HideDiscussion"]';=]@@%0ahinzufügen.%0a%0aQ: Anscheinend trifft (.*?) in den Funktionen nicht auf Zeilenumbrüche zu, sodass das obige Beispiel nicht funktioniert, wenn der Text, der in %3cem> eingeklammert werden soll, Zeilenumbrüche enthält.%0aA: Wenn Sie den "s"-Modifier im regulären Ausdruck verwenden, wird der Punkt (.) auf einen Zeilenumbruch passen. So wird Ihr regulärer Ausdruck zu "/KRAMS(.*?)/s". Das "s" ganz am Ende ist es, wonach Sie suchten. Wenn Sie beginnen, sich mit mehrzeiligen Ausdrücken zu beschäftigen, sollten Sie sich auch mal die m-Option anzusehen &ndash; durch sie passen die Anker (^und $) nicht nur auf den Beginn und das Ende der Zeichenkette, sondern auch auf den Beginn und das Ende von Zeilen, also unmittelbar vor und hinter dem Zeilenumbruch. Versichern Sie sich auch, dass Ihr Markup während der Volltextphase ausgeführt wird.%0a%0aQ: [[#PRR]] Wie kann der Text, den meine Markup-Funktion zurückliefert, noch einmal den Markup-Prozess durchlaufen?%0aA: Wenn das Ergebnis Ihres Markups weitere Markups enthält, die auch noch behandelt werden sollen, haben Sie zwei Optionen. Die erste ist, ein "wann"-Argument zu wählen, dass vor dem Markup in Ihrem Ergebnis bearbeitet wird. Wenn zum Beispiel Ihr Markup [=[[links]]=] zurückliefert, könnte Ihr "wann"-Argument @@"%3clinks"@@ sein, und Ihr Markup wird vor den Verweisen behandelt. Die zweite Option ist, die %25hlt php%25@@PRR()@@-Funktion in Ihrer Markup-Definition aufzurufen oder innerhalb Ihrer Markup-Funktion. In dem Falle beginnt PmWiki alle Markups von vorn, wenn Ihre Behandlung abgeschlossen ist.%0a%0aQ: Wie beginne ich mit dem Schreiben von Rezepten und dem Erzeugen von eigenen Markups?%0aA: [[PmWikiDe/CustomMarkupAlt|(alternative) Einführung in angepasste Auszeichnungen für Anfänger]]%0a%0aQ: Wie mache ich eine Regel, die einmalig nach der Behandlung aller anderen Regeln angewendet wird?%0aA: Wenden Sie diese Anweisung anstelle des üblichen %25hlt php%25@@Markup()@@-Aufrufs an:%0a-->%25hlt php%25@@$MarkupFrameBase['posteval']['myfooter'] = "\$out = onetimerule(\$out);";@@%0a[[#faqend]]%0a>>%3c%3c%0a%0aCategory: [[!Markup]]
time=1671261758
title=Eigene Auszeichnungen
