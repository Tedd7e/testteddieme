version=pmwiki-2.3.9 ordered=1 urlencoded=1
author=MFWolff
charset=UTF-8
csum=typo (+0)
ctime=1161092723
name=PmWiki.CustomPagelistSortOrder
rev=18
targets=PmWiki.BasicVariables,PmWiki.PagelistVariables,Cookbook.CustomPagelistSortOrderFunctions
text=(:Summary:Setting custom sort order for [[PmWiki/page lists]]:)%0a%0aPmWiki can have custom pagelist @@order=@@ values pre-set by the wiki admin in @@config.php@@.  %0aFirst, we have to tell PmWiki which function to call in response to the custom @@order=@@ parameter.  %0a%0aAs an example we have a @@Data-@@ page that contains page text variables storing data about books.  The @@Data-Group.PageName@@ page contains the colon-delimited values @@$:Year@@ (year of publication), @@$:Work@@ (title of the book), and @@$:Author@@ (author of the book).   In some cases the sort-order data for @@Group.PageName@@ needs to come from these corresponding @@Data-@@ pages.%0a%0aThere are two ways to create a custom pagelist order criteria for the pagelists.   %0a%0a!!!Method 1%0aIf the custom sort-order desired is @@$:Year,$:Work,$:Author@@, let's use '@@yearworkauthor@@' as the custom function order parameter, in which case the pagelist criteria would be:%0a->%25pmhlt%25[@(:pagelist order=yearworkauthor:)@]%0a%0aThe array that maps order= parameters to custom comparison code to be called to perform comparisons is @@$PageListSortCmp@@:%0a%0a->%25hlt php%25[@$PageListSortCmp['yearworkauthor'] = 'YearWorkAuthor';@] # only a function name (recommended)%0aor previously%0a->%25color=#888%25 [@$PageListSortCmp['yearworkauthor'] = 'YearWorkAuthor($x, $y)';@] %25%25# deprecated since PHP 7.2%0a%0a@@$PageListSortComp@@ is an array of page list functions.  Each function listed (after the =) expects two parameters -- each contains the pagenames for a page to be sorted; only two pages are compared at a time.  Thus, this says that to perform a comparison between two pages in the pagelist (given by @@$x@@ and @@$y@@), call the function %25hlt php%25@@YearWorkAuthor()@@ and pass those pagenames as arguments. %0a%0aIf you use a function name only, that function will be called with the order as a third argument.%0a%0aThe %25hlt php%25@@YearWorkAuthor()@@%25%25 function should return a value that is less than zero if @@$x@@ should be before @@$y@@ in the list, greater than zero if @@$x@@ should come after @@$y@@, and zero if they're "equivalent" for the purposes of this comparison.%0a%0aOf course, in this scenario, the pages given by @@$x@@ and @@$y@@ don't contain the values we want to sort by -- those values are in the corresponding @@Data-*@@ pages for @@$x@@ and @@$y@@ -- otherwise we wouldn't need to customize the sort order.  Thus, we figure out the names of the "@@Data-@@" pages, and then test the page text variables from those pages:%0a->%25hlt php%25[@function YearWorkAuthor($x, $y) {%0a      ## first, get the Data- versions of the pagenames%0a      $datax = 'Data-' . PageVar($x, '$BaseName');%0a      $datay = 'Data-' . PageVar($y, '$BaseName');%0a%0a      ## compare the $:Year values %0a      $c = strcmp(PageVar($datax, '$:Year'), PageVar($datay, '$:Year'));%0a      if ($c != 0) return $c;%0a%0a      ## compare the $:Work values %0a      $c = strcmp(PageVar($datax, '$:Work'), PageVar($datay, '$:Work'));%0a      if ($c != 0) return $c;%0a%0a      ## compare the $:Author values%0a      $c = strcmp(PageVar($datax, '$:Author'), PageVar($datay, '$:Author'));%0a      return $c;%0a}@]%0a%0aIn the function above, the first two lines figure out the names of the @@Data-*@@ pages%0acorresponding to @@$x@@ and@@ $y@@, and store them in @@$datax@@ and @@$datay@@.%0aThe next two lines grab the @@$:Year@@ page text variables for%0a@@$datax@@ and @@$datay@@, and return a negative or positive value%0aif they're different.  "%25hlt php%25@@strcmp()@@" is a built-in PHP function aka "string compare" and it returns a numeric value that represents how different two pieces of data (text) are.  If they're the same (i.e., @@$c == 0@@), we fall through to test the @@$:Work@@ page text variables, by similar logic, and if those are also the same we test the @@$:Author@@ page text variables and return that.%0a%0aAs written there's a slight bit of overhead in the repeated calls%0ato %25hlt php%25@@PageVar()@@ that we can avoid if speed becomes an issue, but the%0aabove code illustrates the basic concept behind the custom sort.%0a%0a%0a!!!Method 2%0aTo give the wiki user more flexibility, another approach would be to create a generic %25hlt php%25@@DataCompare()@@ function%0afor comparing page text variables in Data-* pages, and then define %0aseparate "year", "work", and "author" options for the @@order=@@ %0aparameter that pass an appropriate argument to %25hlt php%25@@DataCompare()@@:%0a->%25hlt php%25[@function DataCompare($x, $y, $order) {%0a      $var = "$:" . ucfirst($order); # year -> $:Year%0a      ## get the Data- versions of the pagenames%0a      $datax = 'Data-' . PageVar($x, '$BaseName');%0a      $datay = 'Data-' . PageVar($y, '$BaseName');%0a%0a      ## perform the requested comparison%0a      $c = strcmp(PageVar($datax, $var), PageVar($datay, $var));%0a      return $c;%0a}%0a%0a$PageListSortCmp['year']   = 'DataCompare';%0a$PageListSortCmp['work']   = 'DataCompare';%0a$PageListSortCmp['author'] = 'DataCompare';%0a@]%0a%0aNote, the following code was previously valid but will raise Deprecated warnings in PHP 7.2. See above how to update it.%0a>>color:#888%3c%3c%0a->[@function DataCompare($x, $y, $var) {%0a      ## get the Data- versions of the pagenames%0a      $datax = 'Data-' . PageVar($x, '$BaseName');%0a      $datay = 'Data-' . PageVar($y, '$BaseName');%0a%0a      ## perform the requested comparison%0a      $c = strcmp(PageVar($datax, $var), PageVar($datay, $var));%0a      return $c;%0a}%0a%0a$PageListSortCmp['year']   = 'DataCompare($x, $y, "$:Year")';%0a$PageListSortCmp['work']   = 'DataCompare($x, $y, "$:Work")';%0a$PageListSortCmp['author'] = 'DataCompare($x, $y, "$:Author")';%0a@]%0a>>%3c%3c%0a%0aThen one can do any number of pagelist @@order=@@ combinations, such as:%0a->%25hlt php%25[@order=year           # sort by $:Year from the Data- pages%0aorder=year,work      # sort by $:Year, then $:Work%0aorder=year,-author   # sort by $:Year, reverse by $:Author%0aorder=author         # sort by $:Author only%0a@]%0a%0aThis is more in keeping with what an author would expect, given that other sort criteria are malleable and nestable by the end user.  If you want your users to be able to customize the sort order without requiring custom re-programming in @@config.php@@ when new needs arise, this is probably the better model.%0a%0a!!![[#alternative]]Alternative way%0aConsidering that page variables %0aare (or should be) the general PmWiki hook for doing custom things%0awith attributes and properties of pages, in whatever form.%0a%0aIn fact, here's *another* way to handle the sort/group/display%0aproblem by defining custom page variables that have exactly what%0ayou want, and without needing to define any custom sort features%0afor %25pmhlt%25[@(:pagelist:)@].%0a%0aLet's define @@$Year@@, @@$Work@@, and @@$Author@@ page variables for%0aevery page, such that the values of @@$Year@@, @@$Work@@, and @@$Author@@ for any%0apage @@Group.XYZ@@ are always the @@$:Year@@, @@$:Work@@, and @@$:Author@@ page%0atext variable from @@Group.XYZ@@'s corresponding @@Data-*@@ page.   In%0aother words, %25pmhlt%25[@{$Year}@] for any page will always act as if one had specified [@{Data-{$BaseName}$:Year}@].%0a%0aHere are the definitions:%0a->%25hlt php%25[@$FmtPV['$Year'] =%0a  "PageTextVar('Data-'.MakeBaseName(\$pn), 'Year')";%0a%0a$FmtPV['$Work'] =%0a  "PageTextVar('Data-'.MakeBaseName(\$pn), 'Work')";%0a%0a$FmtPV['$Author'] =%0a  "PageTextVar('Data-'.MakeBaseName(\$pn), 'Author')";@]%0a%0aOkay, so what does this buy us?  Well, the value of %25pmhlt%25[@{$Year}@] for any page will always be the value of [@{$:Year}@] from its corresponding @@Data-@@ page.  %0aThus %25pmhlt%25[@{Group.Steinbeck$Year}@] always returns the value of [@{Data-Group.Steinbeck$Year}@].  %0aWhat's more, this works even if the current page is in Data-Simile -- i.e., the value of %25pmhlt%25[@{Data-Group.Steinbeck$Year}@] is the same as [@{Data-Group.Steinbeck$:Year}@].  %0a(The first is a page variable, the second is a page text variable.)%0a%0aSo, what we've done is to move all of the issues of relating%0apages to @@Data-@@ pages out of the pagelist template and into%0asome relatively simple page variable definitions.  With this%0ain place, our pagelist directives then look like:%0a->%25pmhlt%25[@(:pagelist group=Group order=$Year,$Work,$Author:)%0a(:pagelist group=Data-Group order=$Year,$Work,$Author:)%0a@]%0a%0aThe specification of order=@@$Year,$Work,$Author@@ (page variables)%0ameans that we will sort the list of pages based on the%0a@@$:Year@@, @@$:Work@@, and @@$:Author@@ page text variables of the%0acorresponding pages in the @@Data-Group@@ group.%0a%0aNote that we also don't have to worry about whether the%0apagelist is running through the pages of the @@Simile@@ or%0a@@Data-Simile@@ groups, because our custom page variables%0aalways map the pagename into the @@Data-@@ form of the group.%0a%0aThis also greatly simplifies the pagelist template, because%0awe can now write:%0a->%25pmhlt%25[@(:if ! equal {%3c$Year} {=$Year}:)%0a!! {=$Year}%0a(:ifend:)@]%0a%0aAgain, the '@@$Year@@' page variable is taking care of the%0adetails of obtaining @@$:Year@@ from the correct [@Data-{$BaseName}@]%0apage, instead of trying to force the evaluation through the%0amarkup.%0a%0a!! See Also%0a* $PageListSortCmpFunction%0a* Cookbook:CustomPagelistSortOrderFunctions - {Cookbook.CustomPagelistSortOrderFunctions$:Summary}%0a
time=1660984094
